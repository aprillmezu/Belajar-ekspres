"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const globals_1 = require("@jest/globals");
const supertest_1 = __importDefault(require("supertest"));
const app_1 = require("./app");
const express_1 = require("express");
const http_error_1 = require("../errors/http.error");
const http_1 = require("http");
(0, globals_1.describe)('App', () => {
    (0, globals_1.describe)('listen', () => {
        (0, globals_1.test)('listen to default port', () => __awaiter(void 0, void 0, void 0, function* () {
            const app = new app_1.App();
            app.listen();
            try {
                yield (0, supertest_1.default)(`http://localhost:3000`).get('/').expect(404);
            }
            finally {
                app.stop();
            }
        }));
        (0, globals_1.test)('listen callback', () => __awaiter(void 0, void 0, void 0, function* () {
            const app = new app_1.App();
            const listenCallback = globals_1.jest.fn((port) => { });
            app.listen(listenCallback);
            try {
                yield (0, supertest_1.default)(`http://localhost:3000`).get('/').expect(404);
            }
            finally {
                app.stop();
            }
            (0, globals_1.expect)(listenCallback).toHaveBeenCalled();
            (0, globals_1.expect)(listenCallback.mock.calls[0][0]).toBe(3000);
        }));
    });
    (0, globals_1.describe)('port', () => {
        (0, globals_1.test)('set port', () => __awaiter(void 0, void 0, void 0, function* () {
            const app = new app_1.App();
            app.setPort(5000).listen();
            try {
                yield (0, supertest_1.default)(`http://localhost:5000`).get('/').expect(404);
            }
            finally {
                app.stop();
            }
        }));
    });
    (0, globals_1.describe)('server', () => {
        (0, globals_1.test)('get server object', () => {
            (0, globals_1.expect)(new app_1.App().getServer()).toBeInstanceOf(http_1.Server);
        });
    });
    (0, globals_1.describe)('middleware', () => {
        (0, globals_1.test)('set middleware', () => __awaiter(void 0, void 0, void 0, function* () {
            const app = new app_1.App();
            const middlewares = [
                globals_1.jest.fn((req, res, next) => {
                    next();
                }),
                globals_1.jest.fn((req, res, next) => {
                    next();
                }),
            ];
            app.setMiddlewares(middlewares);
            yield (0, supertest_1.default)(app.getServer()).get('/').expect(404);
            (0, globals_1.expect)(middlewares[0]).toHaveBeenCalled();
            (0, globals_1.expect)(middlewares[1]).toHaveBeenCalled();
        }));
    });
    (0, globals_1.describe)('routes', () => {
        (0, globals_1.test)('set routes', () => __awaiter(void 0, void 0, void 0, function* () {
            const app = new app_1.App();
            const testRoute = (0, express_1.Router)();
            testRoute
                .route('/')
                .get((req, res) => res.json('Get'))
                .post((req, res) => res.json('Post'))
                .patch((req, res) => res.json('Patch'))
                .delete((req, res) => res.json('Delete'));
            const routes = [testRoute];
            app.setRoutes(routes);
            yield (0, supertest_1.default)(app.getServer()).get('/').expect(200);
            yield (0, supertest_1.default)(app.getServer()).post('/').expect(200);
            yield (0, supertest_1.default)(app.getServer()).patch('/').expect(200);
            yield (0, supertest_1.default)(app.getServer()).delete('/').expect(200);
        }));
    });
    (0, globals_1.describe)('error', () => {
        (0, globals_1.test)('throw 500 error', () => __awaiter(void 0, void 0, void 0, function* () {
            const router = (0, express_1.Router)();
            const app = new app_1.App().setRoutes([
                router.get('/', (req, res) => {
                    throw new Error('Something Error');
                }),
            ]);
            const res = yield (0, supertest_1.default)(app.getServer()).get('/').expect(500);
            const errorRes = {
                name: 'Internal Server Error',
                message: 'Something Error',
                status: 500,
            };
            (0, globals_1.expect)(res.body).toEqual(errorRes);
        }));
        (0, globals_1.test)('throw http error', () => __awaiter(void 0, void 0, void 0, function* () {
            const router = (0, express_1.Router)();
            const forbiddenError = new http_error_1.HttpError({
                name: 'Forbidden',
                message: 'You dont have access',
            }, 403);
            const unprocessableEntityError = new http_error_1.HttpError({
                name: 'Unprocessable Content',
                message: 'Invalid payload',
                details: [
                    {
                        path: '/',
                        value: null,
                    },
                ],
            }, 422);
            const app = new app_1.App().setRoutes([
                router.get('/', (req, res) => {
                    throw forbiddenError;
                }),
                router.post('/', (req, res) => {
                    throw unprocessableEntityError;
                }),
            ]);
            const forbiddenRes = yield (0, supertest_1.default)(app.getServer())
                .get('/')
                .expect(403);
            const forbiddenErrorRes = {
                message: forbiddenError.message,
                name: forbiddenError.name,
                status: forbiddenError.status,
            };
            (0, globals_1.expect)(forbiddenRes.body).toEqual(forbiddenErrorRes);
            const unprocessableEntityRes = yield (0, supertest_1.default)(app.getServer())
                .post('/')
                .expect(422);
            const unprocessableErrorRes = {
                message: unprocessableEntityError.message,
                name: unprocessableEntityError.name,
                status: unprocessableEntityError.status,
                details: unprocessableEntityError.details,
            };
            (0, globals_1.expect)(unprocessableEntityRes.body).toEqual(unprocessableErrorRes);
        }));
    });
});
